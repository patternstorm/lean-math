import Core.NaturalDeduction
import Core.Universe

/-!
# Predicates As Sets
A `Predicate` partitions the `Particulars` in our `Universe` in two, according to whether they satisfy the `Predicate` or not.
We call `Sets` these partitions.

A specific important case of partitions are those generated by the `Predicates` P(x) = True and P(x) = False, which
partition the `Universe` into a `Set` that contains all `Particulars` in the `Universe`, i.e. the `Universal Set`,
and a `Set` that contains no `Particulars`, i.e. the `Empty Set`.

We can now define operations on `Sets` based on well-known `Predicate` operations and show that they are well-defined
and match the traditional set-theoretic operations.

The result is that we derived *Set Theory* from *Logic* (expressed through *Type Theory* via the Curry-Howard
isomorphism), by defining the meaning of `Set` membership in terms of `Predicate` satisfaction,
as opposed to introducing it as primitive notion, requiring axioms to define its behavior, like ZFC does.
All traditional set operations and properties emerge from logical primitives, e.g. the existence of the `Empty Set` is derived
from falsehood, `Set` equality by extensionality from `Predicate` equality - two `Predicates` are equal if they are logically
equivalent -, and crucially, we do not need the *Axiom of Infinity* because we show that the `Universe` is a `Set` whether
it's finite or infinite.

Notice also, that the way we define `Sets` avoids the *Russell Paradox* by "stratification", because it establishes an infinite
hierarchy of `Particulars` we can reason about:

**Note on Terminology**: At each level, the entities being reasoned about are called `Particulars` relative to
that level's discourse. When we construct `Sets` at one level and then reason about those `Sets` at the next level,
those `Sets` become the `Particulars` of the higher-level discourse.

- *`Level 0 Particulars`*: the initial, i.e. base, `Particulars` we want to reason about.

- *`Level 1 Particulars`* (`Sets` of `Level 0 Particulars`): groupings of `Level 0 Particulars` according to their properties.
  A *Level 1 Particular* is a `Set` which contains only `Level 0 Particulars`, never other `Level 1 Particulars`.

- *`Level 2 Particulars`* (`Sets` of `Sets` of `Level 0 Particulars`): groupings of `Level 1 Particulars` according to their
properties.  A *Level 2 Particular* contains only `Level 1 Particulars`, i.e. `Sets` of `Level 0 Particulars`, never `Level 2 Particulars`.

- **Level 3 and beyond**: Each level groups `Particulars` from the immediately preceding level, according to their properties,
continuing indefinitely.

**Why This Prevents Russell's Paradox**: Russell's "set of all sets not containing themselves" requires a `Set`
to exist at the same level as its potential elements. But the hierarchy ensures `Sets` always exist one level
above their elements, making self-membership impossible at every level.

**Why the Universe Set Exists**: The `Universal Set` is a `Level 1 Particular` defined by the `Predicate`
"being a `Level 0 Particular`". It contains all `Level 0 Particulars` but is itself a `Level 1 Particular`,
distinct from what it contains. There is no "set of all sets at all levels" because each level's totality
can only be described by the next level.


In the following: let `P₍a₎` denote the `Predicate` that gives place to the `Set` `A`.
-/

namespace Universe

namespace Sets

-- # A `Set` is a `Predicate`
def Set := Predicate

-- # `Set` Equality: two `Sets` are equal if their predicates are logically equivalent.
def eq (A B: Set X): Prop := ∀ (x: Particular X), A x ↔ B x
notation:50 A:51 " =ₛₑₜ " B:51 => eq A B

-- # `Set` Membership, a `Particular` `x` is a member of the `Set` `A` if it satisfies its `Predicate`.
def mem (x: Particular X) (A: Set X): Prop := A x
notation:50 x:51 " ∈ₛₑₜ " A:51 => mem x A  -- Explicit precedence for arguments

-- # Foundational `Sets`
-- The `Universal Set`
def universeSet : Set X := fun _ => True
notation "Uₛₑₜ" => universeSet
-- The `Empty Set`.
def emptySet : Set X := fun _ => False
notation "∅ₛₑₜ" => emptySet

-- # Set operations.
-- The complementary of `Set` `A` is the `Set` defined by the `Predicate` `¬P₍a₎`.
def compl (A: Set X): Set X := fun (x: Particular X) => ¬(A x)
prefix:max "¬ₛₑₜ" => compl

-- The intersection of the `Sets` `A` and `B` is a `Set` defined by the predicate `P₍a₎(x) ∧ P₍b₎(x)`.
def inter (A B: Set X): Set X := fun (x: Particular X) => A x ∧ B x
infixl:70 " ∩ₛₑₜ " => inter

-- The union of the `Sets` `A` and `B` is a `Set` defined by the predicate `P₍a₎(x) ∨ P₍b₎(x)`.
def union (A B: Set X): Set X := fun (x: Particular X) => A x ∨ B x
infixl:65 " ∪ₛₑₜ " => union

-- The `Set` `A` is a subset of the `Set` `B` if and only if `P₍a₎(x) → P₍b₎(x)`.
def subset (A B: Set X) : Prop := ∀ (x: Particular X), A x → B x
infix:50 " ⊆ₛₑₜ " => subset


-- # Theorems

-- `Set` equality is well defined, it's extensional ,i.e. Two sets are equal if and only if they have the same elements.
theorem set_extensionality: ∀ (S₁: Set X), ∀ (S₂: Set X),
  S₁ =ₛₑₜ S₂ ↔ (∀ (x: Particular X), x ∈ₛₑₜ S₁ ↔ x ∈ₛₑₜ S₂) := by
    have h₁: ∀ (S₁: Set X), ∀ (S₂: Set X), S₁ =ₛₑₜ S₂ ↔ (∀ (x: Particular X), x ∈ₛₑₜ S₁ ↔ x ∈ₛₑₜ S₂) := by forall_intro
      variable (A: Set X)
      variable (B: Set X)
      have h₁₁: A =ₛₑₜ B ↔ (∀ (x: Particular X), x ∈ₛₑₜ A ↔ x ∈ₛₑₜ B) := by
        have h₁₁₁: A =ₛₑₜ B → (∀ (x: Particular X), x ∈ₛₑₜ A ↔ x ∈ₛₑₜ B) := by
          assume (h₁₁₁₁: A =ₛₑₜ B)
          iterate h₁₁₁₁
        have h₁₁₂: (∀ (x: Particular X), x ∈ₛₑₜ A ↔ x ∈ₛₑₜ B) → A =ₛₑₜ B := by
          assume (h₁₁₂₁: ∀ (x: Particular X), x ∈ₛₑₜ A ↔ x ∈ₛₑₜ B)
          iterate h₁₁₂₁
        iff_intro h₁₁₁, h₁₁₂
    iterate h₁

-- The `Universal Set` exists and it's well defined, i.e. contains all `Particulars`.
theorem universal_set_existenc: ∃ (S: Set X), ∀ (x: Particular X), x ∈ₛₑₜ S := by
  have h₁: ∀ (x: Particular X), x ∈ₛₑₜ Uₛₑₜ := by forall_intro
    variable (u: Particular X)
    have h₁₁: u ∈ₛₑₜ Uₛₑₜ := by true_intro
    iterate h₁₁
  have h₂: ∃ (U: Set X), ∀ (x: Particular X), x ∈ₛₑₜ U := by exists_intro h₁, Uₛₑₜ
  iterate h₂

-- The `Empty Set` exists, and it's well defined, i.e. contains no `Particulars`.
theorem empty_set_existence: ∃ (S: Set X), ∀ (x: Particular X), ¬(x ∈ₛₑₜ S) := by
  have h₁: ∀ (x: Particular X), ¬(x ∈ₛₑₜ ∅ₛₑₜ) := by forall_intro
    variable (u: Particular X)
    have h₁₁: (u ∈ₛₑₜ ∅ₛₑₜ) → False := by
      assume (h₁₁₁: u ∈ₛₑₜ ∅ₛₑₜ)
      iterate h₁₁₁
    have h₁₂: ¬(u ∈ₛₑₜ ∅ₛₑₜ) := by reductio_ad_absurdum h₁₁
  have h₂: ∃ (E : Set X), ∀ (x : Particular X), ¬(x ∈ₛₑₜ E) := by exists_intro h₁, ∅ₛₑₜ
  iterate h₂

--The `Empty Set` is unique.
theorem empty_set_uniqueness: ∀ (S₁: Set X), ∀ (S₂: Set X),
  ((∀ (x: Particular X), ¬(x ∈ₛₑₜ S₁)) ∧ (∀ (x : Particular X), ¬(x ∈ₛₑₜ S₂))) → S₁ =ₛₑₜ S₂ := by
    have h₁: ∀ (S₁: Set X), ∀ (S₂ : Set X),
            ((∀ (x: Particular X), ¬(x ∈ₛₑₜ S₁)) ∧ (∀ (x: Particular X), ¬(x ∈ₛₑₜ S₂))) → S₁ =ₛₑₜ S₂ := by forall_intro
      variable (A: Set X)
      variable (B: Set X)
      have h₁₁: ((∀ (x: Particular X), ¬(x ∈ₛₑₜ A) ∧ ¬(x ∈ₛₑₜ B))) → (A =ₛₑₜ B) := by
        assume (h₁₁₁: ∀ (x: Particular X), (¬(x ∈ₛₑₜ A) ∧ ¬(x ∈ₛₑₜ B)))
        variable (u: Particular X)
        have h₁₁₁₁: (¬(u ∈ₛₑₜ A) ∧ ¬(u ∈ₛₑₜ B)) := by forall_elim h₁₁₁, u
        have h₁₁₁₂: ((u ∈ₛₑₜ A) ↔ (u ∈ₛₑₜ B)) ↔ ((¬(u ∈ₛₑₜ A)) ↔ (¬(u ∈ₛₑₜ B))) := pc₀.iff_contrapositiveness
        have h₁₁₁₃: ((¬(u ∈ₛₑₜ A)) ↔ (¬(u ∈ₛₑₜ B))) → ((u ∈ₛₑₜ A) ↔ (u ∈ₛₑₜ B))  := by iff_elim_r2l h₁₁₁₂
        have h₁₁₁₄: (¬(u ∈ₛₑₜ A)) ↔ (¬(u ∈ₛₑₜ B)) := by
          have h₁₁₁₄₁: (¬(u ∈ₛₑₜ A)) → (¬(u ∈ₛₑₜ B)) := by
            assume (h₁₁₁₄₁₁: ¬u ∈ₛₑₜ A)
            have h₁₁₁₄₁₂: ¬u ∈ₛₑₜ B := by and_elim h₁₁₁₁
            iterate h₁₁₁₄₁₂
          have h₁₁₁₄₂: (¬(u ∈ₛₑₜ B)) → (¬(u ∈ₛₑₜ A)) := by
            assume (h₁₁₁₄₂₁: ¬u ∈ₛₑₜ B)
            have h₁₁₁₄₂₂: ¬u ∈ₛₑₜ A := by and_elim h₁₁₁₁
            iterate h₁₁₁₄₂₂
          iff_intro h₁₁₁₄₁, h₁₁₁₄₂
        have h₁₁₁₅: (u ∈ₛₑₜ A) ↔ (u ∈ₛₑₜ B) := by modus_ponens h₁₁₁₃, h₁₁₁₄
        iterate h₁₁₁₅
      have h₁₂: (∀ (x: Particular X), ¬(x ∈ₛₑₜ A)) ∧ (∀ (x: Particular X), ¬(x ∈ₛₑₜ B)) ↔
                (∀ (x: Particular X), ¬(x ∈ₛₑₜ A) ∧ ¬(x ∈ₛₑₜ B)) := pc₁.forall_and_full_dist
      have h₂₂: (∀ (x: Particular X), ¬(x ∈ₛₑₜ A)) ∧ (∀ (x: Particular X), ¬(x ∈ₛₑₜ B)) →
                (∀ (x: Particular X), ¬(x ∈ₛₑₜ A) ∧ ¬(x ∈ₛₑₜ B)) := by iff_elim_l2r h₁₂
      have h₂₂₂: ((∀ (x: Particular X), ¬(x ∈ₛₑₜ A)) ∧ (∀ (x: Particular X), ¬(x ∈ₛₑₜ B))) → A =ₛₑₜ B :=
        pc₀.hypothetical_syllogism h₂₂ h₁₁
      iterate h₂₂₂
    iterate h₁


-- ## Theorems, showing that the `Set` operations are well-defined.
theorem complement_operation_is_well_defined (A: Set X) (x : Particular X) :
  x ∈ₛₑₜ (¬ₛₑₜA) ↔ ¬(x ∈ₛₑₜ A) := by
    unfold mem compl
    rfl

theorem intersection_is_well_defined (A B: Set X) (x : Particular X) :
  x ∈ₛₑₜ (A ∩ₛₑₜ B) ↔ (x ∈ₛₑₜ A ∧ x ∈ₛₑₜ B) := by
    unfold mem inter
    rfl

theorem union_is_well_defined (A B : Set X) (x : Particular X) :
  x ∈ₛₑₜ (A ∪ₛₑₜ B) ↔ (x ∈ₛₑₜ A ∨ x ∈ₛₑₜ B) := by
    unfold mem union
    rfl

theorem subset_relation_is_well_defined (A B: Set X) :
  (A ⊆ₛₑₜ B) ↔ (∀ (x: Particular X), x ∈ₛₑₜ A → x ∈ₛₑₜ B) := by
    unfold subset mem
    rfl

-- ## Theorems showing the `Universe` and the `Empty Set` are complements.
theorem the_empty_set_is_the_complement_of_the_universe_set:
  ¬ₛₑₜemptySet = (universeSet: Set X) := by
    funext x
    unfold compl emptySet universeSet
    simp

theorem the_universe_set_is_the_complement_of_the_empty_set:
  ¬ₛₑₜuniverseSet = (emptySet: Set X) := by
    funext x
    unfold compl universeSet emptySet
    simp

end Sets

end Universe
