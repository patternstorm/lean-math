import Core.NaturalDeduction
import Core.Equality
import Core.Universe

/-!
# Sets as Unary Predicates
A `Unary Predicate` introduces structure into the `Universe`, it partitions the `Particulars` into two, according to whether they satisfy the `Predicate` or not.
We call `Sets` these partitions.

A specific important case of partitions are those generated by the `Unary Predicates` P(x) = True and P(x) = False, which
partition the `Universe` into a `Set` that contains all `Particulars` in the `Universe`, i.e. the `Universal Set`,
and a `Set` that contains no `Particulars`, i.e. the `Empty Set`.

We can now define operations on `Sets` based on well-known `Predicate` operations and show that they are well-defined
and match the traditional set-theoretic operations.

The result is that we derived *Set Theory* from *Logic* (expressed through *Type Theory* via the Curry-Howard
isomorphism), by defining the meaning of `Set` membership in terms of `Predicate` satisfaction,
as opposed to introducing it as primitive notion, requiring axioms to define its behavior, like ZFC does.
All traditional `Set` operations and properties emerge from logical primitives: the existence of the `Empty Set` is derived
from falsehood, `Set` equality by extensionality from `Predicate` equality (two `Predicates` are equal if they are logically
equivalent), the `Powerset` is simply a predicate over predicates (`Sets` of `Sets`) requiring no additional axiom, and
crucially, we do not need the *Axiom of Infinity* because we show that the `Universe` is a `Set` whether it's finite
or infinite. Thus, three of ZFC's fundamental axioms (Empty Set, Powerset, and Infinity) are unnecessary—they are
either derived or rendered superfluous by our logical foundation.

Notice also that, while **Russell's Paradox** can still be expressed in the framework, by using an inconsistent `Recursive Predicate Definition`,
e.g. `P(x) := x ∉ P` (we already addressed this in `NaturalDeduction.md` Note 3), its realization via self-containment is prevented by the way
we define `Sets`, which creates an "stratification" that establishes an infinite hierarchy of `Particulars` we can reason about:

**Note on Terminology**: At each level, the entities being reasoned about are called `Particulars` relative to
that level's discourse. When we construct `Sets` at one level and then reason about those `Sets` at the next level,
those `Sets` become the `Particulars` of the higher-level discourse.

- *`Level 0 Particulars`*: the initial, i.e. base, `Particulars` we want to reason about.

- *`Level 1 Particulars`* (`Sets` of `Level 0 Particulars`): groupings of `Level 0 Particulars` according to their properties.
  A *Level 1 Particular* is a `Set` which contains only `Level 0 Particulars`, never other `Level 1 Particulars`.

- *`Level 2 Particulars`* (`Sets` of `Sets` of `Level 0 Particulars`): groupings of `Level 1 Particulars` according to their
properties.  A *Level 2 Particular* contains only `Level 1 Particulars`, i.e. `Sets` of `Level 0 Particulars`, never `Level 2 Particulars`.

- **Level 3 and beyond**: Each level groups `Particulars` from the immediately preceding level, according to their properties,
continuing indefinitely.

**Why This Prevents Russell's Paradox**: Russell's "set of all sets not containing themselves" requires a `Set`
to exist at the same level as its potential elements. But the hierarchy ensures `Sets` always exist one level
above their elements, making self-membership impossible at every level.

**Why This embeds (Finite) Higher-Order Logic Into First Order Logic**

A profound consequence of this framework is that it embeds higher-order logic within first-order logic, not by
adding new quantification rules, but as a natural consequence of defining `Sets` as `Predicates`.

Since `Sets`, i.e. `Set X`, are defined as a type whose terms are `Predicates` over `X`, first-order quantification over `Set X`
(e.g., `∀ S : Set X, ...`) syntactically uses first order typed quantification while semantically capturing predicate
quantification — achieving second-order logic within first-order syntax.

Similarly, `Sets`of `Sets`, i.e. `Set (Set X)`, are defined as a type whose terms are `Predicates` over `Sets`, i.e.
`Predicates` over `Predicates` over `X`, making first-order quantification over it semantically third-order, continuing
this pattern for all finite orders.

- **Key Distinction from Traditional Approaches**: Traditional higher-order logics introduce new syntactic machinery
(quantifiers over predicates, functions, etc.) as primitive extensions to first-order logic. Our framework shows
this is unnecessary: higher-order reasoning emerges *inevitably* from first-order logic once we:
  1. Define `Sets` as the extension of `Predicates`.
  2. Allow `Sets` themselves to become `Particulars` at the next level.

The stratification hierarchy is not an artificial restriction—it is the natural structure through which first-order
logic, given the right notion of predicate, generates all finite orders of higher-order logic internally.

**Why the Universe Set Exists**: The `Universal Set` is a `Level 1 Particular` defined by the `Predicate`
"being a `Level 0 Particular`". It contains all `Level 0 Particulars` but is itself a `Level 1 Particular`,
distinct from what it contains. There is no "set of all sets at all levels" because each level's totality
can only be described by the next level.


In the following: let `P₍a₎` denote the `Predicate` that gives place to the `Set` `A`.
-/

namespace Universe

namespace Sets

-- # A `Set` is a `Unary Predicate`
def Set := UnaryPredicate

-- # Set equality
axiom eq: Set X → Set X → Prop
notation:50 A:51 " =ₛₑₜ " B:51 => eq A B

axiom eq_refl: ∀ (S: Set X), S =ₛₑₜ S
axiom eq_poly_eq : ∀ (S₁: Set X), ∀ (S₂: Set X), S₁ =ₛₑₜ S₂ ↔ S₁ =ₚ S₂
-- NOTE, we should be able to derive these
axiom eq_sym: ∀ (S₁: Set X), ∀ (S₂: Set X), S₁ =ₛₑₜ S₂ → S₂ =ₛₑₜ S₁
axiom eq_trans: ∀ (S₁: Set X), ∀ (S₂: Set X), ∀ (S₃: Set X), S₁ =ₛₑₜ S₂ ∧ S₂ =ₛₑₜ S₃ → S₁ =ₛₑₜ S₃


-- ## Two `Sets` are equal if their predicates are logically equivalent.
axiom eq_def: ∀ S₁: Set X, ∀ S₂: Set X, S₁ =ₛₑₜ S₂ ↔ ∀ (x: Particular X), S₁ x ↔ S₂ x

-- # `Set` Membership, a `Particular` `x` is a member of the `Set` `A` if it satisfies its `Predicate`.
axiom mem: Particular X → Set X → Prop
notation:50 x:51 " ∈ₛₑₜ " S:51 => mem x S  -- Explicit precedence for arguments

axiom mem_def: ∀ (S: Set X), ∀ (x: Particular X), x ∈ₛₑₜ S ↔ S x

axiom not_mem: Particular X → Set X → Prop
notation:50 x:51 " ∉ₛₑₜ " S:51 => not_mem x S  -- Explicit precedence for arguments

axiom not_mem_def: ∀ (S: Set X), ∀ (x: Particular X), x ∉ₛₑₜ S ↔ ¬(S x)

theorem not_mem_def_neg_mem_eq {A: Set X} {u: Particular X}: (u ∉ₛₑₜ A) ↔ ¬(u ∈ₛₑₜ A) := by
    have h₂: ∀ (x: Particular X), x ∉ₛₑₜ A ↔ ¬(A x) := by forall_elim not_mem_def, A
    have h₃: u ∉ₛₑₜ A ↔ ¬(A u) := by forall_elim h₂, u
    have h₄: ∀ (x: Particular X), x ∈ₛₑₜ A ↔ A x := by forall_elim mem_def, A
    have h₅: u ∈ₛₑₜ A ↔ A u := by forall_elim h₄, u
    have h₆: (u ∈ₛₑₜ A ↔ A u) ↔ (¬(u ∈ₛₑₜ A) ↔ ¬(A u)) := pc₀.iff_contrapositiveness
    have h₇: ¬(u ∈ₛₑₜ A) ↔ ¬(A u) := pc₀.deductive_eq_l2r h₆ h₅
    have h₁: (u ∉ₛₑₜ A) → ¬(u ∈ₛₑₜ A) := by
      assume(h₁₁: u ∉ₛₑₜ A)
      have h₈: ¬(A u) := pc₀.deductive_eq_l2r h₃ h₁₁
      have h₉: ¬(u ∈ₛₑₜ A) := pc₀.deductive_eq_r2l h₇ h₈
      iterate h₉
    have h₂: ¬(u ∈ₛₑₜ A) → (u ∉ₛₑₜ A) := by
      assume(h₂₁: ¬(u ∈ₛₑₜ A))
      have h₂₂: ¬(A u) := pc₀.deductive_eq_l2r h₇ h₂₁
      have h₂₃: u ∉ₛₑₜ A := pc₀.deductive_eq_r2l h₃ h₂₂
      iterate h₂₃
    iff_intro h₁, h₂

theorem pred_eq_iff_mem_eq {A B: Set X} {u: Particular X}: (A u ↔ B u) ↔ (u ∈ₛₑₜ A ↔ u ∈ₛₑₜ B) := by
      have h₁: ∀ (x: Particular X), x ∈ₛₑₜ A ↔ A x := by forall_elim mem_def, A
      have h₁: u ∈ₛₑₜ A ↔ A u := by forall_elim h₁, u
      have h₂: ∀ (x: Particular X), x ∈ₛₑₜ B ↔ B x := by forall_elim mem_def, B
      have h₂: u ∈ₛₑₜ B ↔ B u := by forall_elim h₂, u
      have h₃: (A u ↔ B u) → (u ∈ₛₑₜ A ↔ u ∈ₛₑₜ B) := by
        assume (h₃₁: A u ↔ B u)
        have h₃₂: u ∈ₛₑₜ A → u ∈ₛₑₜ B := by
          assume (h₃₂₁: u ∈ₛₑₜ A)
          have h₃₂₂: A u := pc₀.deductive_eq_l2r h₁ h₃₂₁
          have h₃₂₃: B u := pc₀.deductive_eq_l2r h₃₁ h₃₂₂
          have h₃₂₄: u ∈ₛₑₜ B := pc₀.deductive_eq_r2l h₂ h₃₂₃
          iterate h₃₂₄
        have h₃₃: u ∈ₛₑₜ B → u ∈ₛₑₜ A := by
          assume (h₃₃₁: u ∈ₛₑₜ B)
          have h₃₃₂: B u := pc₀.deductive_eq_l2r h₂ h₃₃₁
          have h₃₃₃: A u := pc₀.deductive_eq_r2l h₃₁ h₃₃₂
          have h₃₃₄: u ∈ₛₑₜ A := pc₀.deductive_eq_r2l h₁ h₃₃₃
          iterate h₃₃₄
        iff_intro h₃₂, h₃₃
      have h₄: (u ∈ₛₑₜ A ↔ u ∈ₛₑₜ B) → (A u ↔ B u) := by
        assume (h₄₁: u ∈ₛₑₜ A ↔ u ∈ₛₑₜ B)
        have h₄₂: A u → B u := by
          assume (h₄₂₁: A u)
          have h₄₂₂: u ∈ₛₑₜ A := pc₀.deductive_eq_r2l h₁ h₄₂₁
          have h₄₂₃: u ∈ₛₑₜ B := pc₀.deductive_eq_l2r h₄₁ h₄₂₂
          have h₄₂₄: B u := pc₀.deductive_eq_l2r h₂ h₄₂₃
          iterate h₄₂₄
        have h₄₃: B u → A u := by
          assume (h₄₃₁: B u)
          have h₄₃₂: u ∈ₛₑₜ B := pc₀.deductive_eq_r2l h₂ h₄₃₁
          have h₄₃₃: u ∈ₛₑₜ A := pc₀.deductive_eq_r2l h₄₁ h₄₃₂
          have h₄₃₄: A u := pc₀.deductive_eq_l2r h₁ h₄₃₃
          iterate h₄₃₄
        iff_intro h₄₂, h₄₃
      iff_intro h₃, h₄

-- The `Set` `A` is a subset of the `Set` `B` if and only if `P₍a₎(x) → P₍b₎(x)`.
def subset (A B: Set X) : Prop := ∀ (x: Particular X), A x → B x
infix:50 " ⊆ₛₑₜ " => subset


-- # Foundational `Sets`

-- The `Universal Set`
-- NOTE refactor to use def universal_set: Set X := { x: Particular X | True }
axiom universal_set: Set X
notation "Uₛₑₜ" => universal_set
-- This will become a theorem
axiom universal_set_def: ∀ x: Particular X, Uₛₑₜ x ↔ True

-- The `Empty Set`.
-- NOTE refactor to use def universal_set: Set X := { x: Particular X | False }
axiom empty_set : Set X
notation "∅ₛₑₜ" => empty_set
-- This will become a theorem
axiom empty_set_def: ∀ (x: Particular X), ∅ₛₑₜ x ↔ False

-- The `Singleton Set`
def singleton_set: Set X → Prop := (S: Set X ↦ ∃! (x : Particular X), x ∈ₛₑₜ S)
prefix:max "Singleton " => singleton_set

-- Powerset
def Powerset (X: Type): Type := Set (Set X)
def powerset (S: Set X): Set (Set X) := { S': Set X | S' ⊆ₛₑₜ S }

-- # Set operations.
-- The complementary of `Set` `A` is the `Set` defined by the `Predicate` `¬P₍a₎`.
def compl (A: Set X): Set X := fun (x: Particular X) => ¬(A x)
prefix:max "¬ₛₑₜ" => compl

-- The intersection of the `Sets` `A` and `B` is a `Set` defined by the predicate `P₍a₎(x) ∧ P₍b₎(x)`.
def inter (A B: Set X): Set X := fun (x: Particular X) => A x ∧ B x
infixl:70 " ∩ₛₑₜ " => inter

-- The union of the `Sets` `A` and `B` is a `Set` defined by the predicate `P₍a₎(x) ∨ P₍b₎(x)`.
def union (A B: Set X): Set X := fun (x: Particular X) => A x ∨ B x
infixl:65 " ∪ₛₑₜ " => union

-- # Theorems

-- `Set` equality is well defined, it's extensional ,i.e. Two sets are equal if and only if they have the same elements.
theorem set_extensionality: ∀ (S₁: Set X), ∀ (S₂: Set X),
  S₁ =ₛₑₜ S₂ ↔ (∀ (x: Particular X), x ∈ₛₑₜ S₁ ↔ x ∈ₛₑₜ S₂) := by

    -- Derive the conclusion via forall_intro
    have h₁: ∀ (S₁: Set X), ∀ (S₂: Set X), S₁ =ₛₑₜ S₂ ↔ (∀ (x: Particular X), x ∈ₛₑₜ S₁ ↔ x ∈ₛₑₜ S₂) := by forall_intro
      variable (A: Set X)
      variable (B: Set X)

      -- From set equality, establish predicate equivalence for arbitrary Sets A and B
      have h₁₁: ∀ S₂: Set X, A =ₛₑₜ S₂ ↔ ∀ (x: Particular X), A x ↔ S₂ x := by forall_elim eq_def, A
      have h₁₂: A =ₛₑₜ B ↔ ∀ (x: Particular X), A x ↔ B x := by forall_elim h₁₁, B

      -- Establish equivalence between membership and predicate application for arbitrary Set A
      have h₁₃: ∀ (x: Particular X), x ∈ₛₑₜ A ↔ A x := by forall_elim mem_def, A

      -- Establish equivalence between membership and predicate application for arbitrary Set B
      have h₁₄: ∀ (x: Particular X), x ∈ₛₑₜ B ↔ B x := by forall_elim mem_def, B

      -- Proof the conclusion for arbitrary Sets A and B
      have h₁₅: A =ₛₑₜ B ↔ (∀ (x: Particular X), x ∈ₛₑₜ A ↔ x ∈ₛₑₜ B) := by

        -- Forward direction: set equality implies membership equivalence
        have h₁₅₁: A =ₛₑₜ B → (∀ (x: Particular X), x ∈ₛₑₜ A ↔ x ∈ₛₑₜ B) := by
          assume (h₁₅₁₁: A =ₛₑₜ B)

          -- Derive the conclusion via forall_intro
          have h₁₅₁₂: ∀ (x: Particular X), x ∈ₛₑₜ A ↔ x ∈ₛₑₜ B := by forall_intro
            variable (u: Particular X)

            -- From the equality of arbitrary Sets A and B, establish membership equivalence
            have h₁₅₁₂₁: ∀ (x: Particular X), A x ↔ B x := pc₀.deductive_eq_l2r h₁₂ h₁₅₁₁
            have h₁₅₁₂₂: A u ↔ B u := by forall_elim h₁₅₁₂₁, u
            have h₁₅₁₂₃: u ∈ₛₑₜ A ↔ u ∈ₛₑₜ B := pc₀.deductive_eq_l2r pred_eq_iff_mem_eq h₁₅₁₂₂
            iterate h₁₅₁₂₃

          iterate h₁₅₁₂

        -- Backward direction: membership equivalence implies set equality
        have h₁₅₂: (∀ (x: Particular X), x ∈ₛₑₜ A ↔ x ∈ₛₑₜ B) → A =ₛₑₜ B := by
          assume (h₁₅₂₁: ∀ (x: Particular X), x ∈ₛₑₜ A ↔ x ∈ₛₑₜ B)

          -- Prove ∀ x, A x ↔ B x, then convert to set equality
          have h₁₅₂₂: ∀ (x: Particular X), A x ↔ B x := by forall_intro
            variable (u: Particular X)

            -- Establish membership equivalence for an arbitrary Particular u
            have h₁₅₂₂₁: u ∈ₛₑₜ A ↔ u ∈ₛₑₜ B := by forall_elim h₁₅₂₁, u
            have h₁₅₂₂₂: A u ↔ B u := pc₀.deductive_eq_r2l pred_eq_iff_mem_eq h₁₅₂₂₁
            iterate h₁₅₂₂₂

          -- Convert predicate equivalence to set equality
          have h₁₅₂₃: A =ₛₑₜ B := pc₀.deductive_eq_r2l h₁₂ h₁₅₂₂
          iterate h₁₅₂₃

        iff_intro h₁₅₁, h₁₅₂

    iterate h₁



-- The `Universal Set` exists and it's well defined, i.e. contains all `Particulars`.
theorem universal_set_existence: ∃ (S: Set X), ∀ (x: Particular X), x ∈ₛₑₜ S := by
  have h₁: ∀ (x: Particular X), x ∈ₛₑₜ Uₛₑₜ := by forall_intro
    variable (u: Particular X)
    have h₁₁: Uₛₑₜ u ↔ True := by forall_elim universal_set_def, u
    have h₁₂: Uₛₑₜ u := pc₀.deductive_eq_r2l h₁₁ True.intro
    have h₁₃: ∀ (x: Particular X), x ∈ₛₑₜ Uₛₑₜ ↔ Uₛₑₜ x := by forall_elim mem_def, Uₛₑₜ
    have h₁₄: u ∈ₛₑₜ Uₛₑₜ ↔ Uₛₑₜ u := by forall_elim h₁₃, u
    have h₁₅: u ∈ₛₑₜ Uₛₑₜ := pc₀.deductive_eq_r2l h₁₄ h₁₂
    iterate h₁₅
  have h₂: ∃ (U: Set X), ∀ (x: Particular X), x ∈ₛₑₜ U := by exists_intro h₁, Uₛₑₜ
  iterate h₂


-- The `Empty Set` exists, and it's well defined, i.e. contains no `Particulars`.
theorem empty_set_existence: ∃ (S: Set X), ∀ (x: Particular X), x ∉ₛₑₜ S := by
  have h₁: ∀ (x: Particular X), x ∉ₛₑₜ ∅ₛₑₜ := by forall_intro
    variable (u: Particular X)
    have h₁₁₃: ∀ (x: Particular X),  x ∈ₛₑₜ ∅ₛₑₜ ↔ ∅ₛₑₜ x := by forall_elim mem_def, ∅ₛₑₜ
    have h₁₁₄: u ∈ₛₑₜ ∅ₛₑₜ ↔ ∅ₛₑₜ u := by forall_elim h₁₁₃, u
    have h₁₁: (u ∈ₛₑₜ ∅ₛₑₜ) → False := by
      assume (h₁₁₁: u ∈ₛₑₜ ∅ₛₑₜ)
      have h₁₁₂: ∅ₛₑₜ u ↔ False := by forall_elim empty_set_def, u
      have h₁₁₅: ∅ₛₑₜ u := pc₀.deductive_eq_l2r h₁₁₄ h₁₁₁
      have h₁₁₆: False := pc₀.deductive_eq_l2r h₁₁₂ h₁₁₅
      iterate h₁₁₆
    have h₁₂: ¬(u ∈ₛₑₜ ∅ₛₑₜ) := by reductio_ad_absurdum h₁₁
    have h₁₃: (u ∉ₛₑₜ ∅ₛₑₜ) ↔ ¬(u ∈ₛₑₜ ∅ₛₑₜ) := not_mem_def_neg_mem_eq
    have h₁₄: u ∉ₛₑₜ ∅ₛₑₜ := pc₀.deductive_eq_r2l h₁₃ h₁₂
    iterate h₁₄
  have h₂: ∃ (E : Set X), ∀ (x : Particular X), x ∉ₛₑₜ E := by exists_intro h₁, ∅ₛₑₜ
  iterate h₂

--The `Empty Set` is unique.
theorem empty_set_uniqueness: ∃! (S: Set X), ∀ (x: Particular X), x ∉ₛₑₜ S := by

  -- P is the predicate for which we want to prove unique existence
  let P: Set X → Prop := (S: Set X ↦ ∀ (x: Particular X), x ∉ₛₑₜ S)

  -- A is the "only" Set that meets P.
  have h₁: ∃ (S: Set X), P S := empty_set_existence
  have ⟨(A: Set X), (h₂: P A)⟩ := exists_elim h₁

  -- Any Set that meets P is equal to A.
  have h₃: ∀ (S: Set X), P S → (S =ₚ A) := by forall_intro
    variable (B: Set X)
    assume (h₂₁: P B)

    -- We first show equal extensionality and then convert to set equality.
    have h₂₂: ∀ (x: Particular X), x ∈ₛₑₜ B ↔ x ∈ₛₑₜ A := by forall_intro
      variable (u: Particular X)
      have h₂₂₁: u ∈ₛₑₜ B → u ∈ₛₑₜ A := by
        assume (h₂₂₁₁: u ∈ₛₑₜ B)
        have h₂₂₁₂: u ∉ₛₑₜ B := by forall_elim h₂₁, u
        have h₂₂₁₃: (u ∉ₛₑₜ B) ↔ ¬(u ∈ₛₑₜ B) := not_mem_def_neg_mem_eq
        have h₂₂₁₄: ¬(u ∈ₛₑₜ B) := pc₀.deductive_eq_l2r h₂₂₁₃ h₂₂₁₂
        have h₂₂₁₅: u ∈ₛₑₜ A := pc₀.quodlibet_seqitur h₂₂₁₁ h₂₂₁₄
        iterate h₂₂₁₅
      have h₂₂₂: u ∈ₛₑₜ A → u ∈ₛₑₜ B := by
        assume (h₂₂₂₁: u ∈ₛₑₜ A)
        have h₂₂₂₂: u ∉ₛₑₜ A := by forall_elim h₂, u
        have h₂₂₁₃: (u ∉ₛₑₜ A) ↔ ¬(u ∈ₛₑₜ A) := not_mem_def_neg_mem_eq
        have h₂₂₂₄: ¬(u ∈ₛₑₜ A) := pc₀.deductive_eq_l2r h₂₂₁₃ h₂₂₂₂
        have h₂₂₂₅: u ∈ₛₑₜ B := pc₀.quodlibet_seqitur h₂₂₂₁ h₂₂₂₄
        iterate h₂₂₂₅
      iff_intro h₂₂₁, h₂₂₂

    -- Convert extensionality to set equality
    have h₂₃: ∀ (S₂: Set X), B =ₛₑₜ S₂ ↔ (∀ (x: Particular X), x ∈ₛₑₜ B ↔ x ∈ₛₑₜ S₂) := by forall_elim set_extensionality, B
    have h₂₄: B =ₛₑₜ A ↔ (∀ (x: Particular X), x ∈ₛₑₜ B ↔ x ∈ₛₑₜ A) := by forall_elim h₂₃, A
    have h₂₅: B =ₛₑₜ A := pc₀.deductive_eq_r2l h₂₄ h₂₂

    -- Convert set equality to polymorphic equality
    have h₂₆: ∀ (S₂: Set X), B =ₛₑₜ S₂ ↔ B =ₚ S₂ := by forall_elim eq_poly_eq, B
    have h₂₇: B =ₛₑₜ A ↔ B =ₚ A := by forall_elim h₂₆, A
    have h₂₈: B =ₚ A := pc₀.deductive_eq_l2r h₂₇ h₂₅
    iterate h₂₈

  -- Introduce unique existence for P
  have h₄: P A ∧ (∀ (S: Set X), P S → (S =ₚ A)) := by and_intro h₂, h₃
  have h₅: ∃ (S': Set X), P S' ∧ (∀ (S: Set X), P S → (S =ₚ S')) := by exists_intro h₄, A
  have h₆: (∃! (S: Set X), P S) ↔
           (∃ (S': Set X), P S' ∧ (∀ (S: Set X), (P S) → (S =ₚ S'))) := by forall_elim exists_unique_def, P
  have h₇: ∃! (S: Set X), P S := pc₀.deductive_eq_r2l h₆ h₅
  iterate h₇

/-!

-- ## Theorems, showing that the `Set` operations are well-defined.
theorem complement_operation_is_well_defined (A: Set X) (x : Particular X) :
  x ∈ₛₑₜ (¬ₛₑₜA) ↔ ¬(x ∈ₛₑₜ A) := by
    unfold mem compl
    rfl

theorem intersection_is_well_defined (A B: Set X) (x : Particular X) :
  x ∈ₛₑₜ (A ∩ₛₑₜ B) ↔ (x ∈ₛₑₜ A ∧ x ∈ₛₑₜ B) := by
    unfold mem inter
    rfl

theorem union_is_well_defined (A B : Set X) (x : Particular X) :
  x ∈ₛₑₜ (A ∪ₛₑₜ B) ↔ (x ∈ₛₑₜ A ∨ x ∈ₛₑₜ B) := by
    unfold mem union
    rfl

theorem subset_relation_is_well_defined (A B: Set X) :
  (A ⊆ₛₑₜ B) ↔ (∀ (x: Particular X), x ∈ₛₑₜ A → x ∈ₛₑₜ B) := by
    unfold subset mem
    rfl

-- ## Theorems showing the `Universe` and the `Empty Set` are complements.
theorem the_empty_set_is_the_complement_of_the_universe_set:
  ¬ₛₑₜemptySet = (universalSet: Set X) := by
    funext x
    unfold compl emptySet universalSet
    simp

theorem the_universe_set_is_the_complement_of_the_empty_set:
  ¬ₛₑₜuniversalSet = (emptySet: Set X) := by
    funext x
    unfold compl universalSet emptySet
    simp

-/

end Sets

end Universe
