import Core.Universe

/-!
# Predicates As Sets
A *Predicate* partitions the *Particulars* in our *Universe* in two - each partition is called a *Set* -,
according to whether they satisfy the *Predicate* or not.

A particular important case of the above is the partition generated by the *Predicate* P(x) = True, which
partitions the *Universe* into a *Set* that contains all *Particulars* in the *Universe*, i.e. the *Universe Set*,
and a *Set* that contains no *Particulars*, i.e. the *Empty Set*.

We can now define operations on *Sets* based on well-known *Predicate* operations and show that they are well-defined
and match the traditional set-theoretic operations.

The result is that we derived *Set Theory* from *Logic* (expressed through *Type Theory* via the Curry-Howard
isomorphism), by defining the meaning of *Set* membership in terms of *Predicate* satisfaction,
as opposed to introducing it as primitive notion, requiring axioms to define its behavior, like ZFC does.
All traditional set operations and properties emerge from logical primitives, e.g. the existence of the *Empty Set* is derived
from falsehood, *Set* equality by extensionality from *Predicate* equality - two *Predicates* are equal if they are logically
equivalent -, and crucially, we do not need the *Axiom of Infinity* because we show that the *Universe* is a *Set* whether
it's finite or infinite.

Notice also, that the way we define *Sets* avoids the *Russell Paradox* by "stratification". The way we
define *Sets* establishes an infinite hierarchy of *Particulars* we can reason about:

**Note on Terminology**: At each level, the entities being reasoned about are called *Particulars* relative to
that level's discourse. When we construct *Sets* at one level and then reason about those *Sets* at the next level,
those *Sets* become the *Particulars* of the higher-level discourse.

- **Level 0 Particulars**: the initial, i.e. base, *Particulars* we want to reason about.

- **Level 1 Particulars (Sets of Level 0 Particulars)**: groupings of *Level 0 Particulars* according to their properties.
  A *Level 1 Particular* is a *Set* which contains only *Level 0 Particulars*, never other *Level 1 Particulars*.

- **Level 2 Particulars (Sets of Sets of Level 0 Particulars)**: groupings of *Level 1 Particulars* according to their
properties.  A *Level 2 Particular* contains only *Level 1 Particulars*, i.e. *Sets* of *Level 0 Particulars*, never *Level 2 Particulars*.

- **Level 3 and beyond**: Each level groups *Particulars* from the immediately preceding level, according to their properties,
continuing infinitely.

**Why This Prevents Russell's Paradox**: Russell's "set of all sets not containing themselves" requires a *Set*
to exist at the same level as its potential elements. But the hierarchy ensures *Sets* always exist one level
above their elements, making self-membership impossible at every level.

**Why the Universe Set Exists**: The *Universe Set* is a *Level 1 Particular* defined by the property
"being a *Level 0 Particular*". It contains all *Level 0 Particulars* but is itself a *Level 1 Particular*,
distinct from what it contains. There is no "set of all sets at all levels" because each level's totality
can only be described by the next level.


In the following: let P_A(_) denote the *Predicate* that gives place to the *Set* A.
-/

namespace Universe

-- # A *Set* is a *Predicate*
def Set := Predicate

-- # *Set* Membership, a *Particular* x is a member of the *Set* A if it satisfies the *Predicate* P_A(_).
def mem (x : Particular X) (A : Set X) : Prop := A x
notation:50 x:51 " ∈ " A:51 => mem x A  -- Explicit precedence for arguments

-- # *Set* Equality: two *Sets* are equal if and only if they have the same members.
theorem set_equality_is_well_defined (A B : Set X) :
  A = B ↔ (∀ (x : Particular X), x ∈ A ↔ x ∈ B) := by
    constructor
    · intro h x
      rw [h]
    · intro h
      funext x
      exact propext (h x)

-- # Foundational *Sets* derived from *Predicates*.
-- The *Universe Set*
def universeSet : Set X := fun _ => True
-- The *Empty Set*.
def emptySet : Set X := fun _ => False
notation "∅" => emptySet

-- ## Theorems showing that the *Universe* and *Empty Set* are well-defined.
-- The **Universe Set** contains all *Particulars*.
theorem the_universe_set_is_well_defined : ∃ (U : Set X), ∀ (x : Particular X), x ∈ U := by
  exists universeSet
  intro x
  unfold mem universeSet
  trivial

-- The **Empty Set** contains no *Particulars*.
theorem the_empty_set_is_well_defined : ∃ (E : Set X), ∀ (x : Particular X), ¬(x ∈ E) := by
  exists emptySet
  intro x
  unfold mem emptySet
  simp

-- The **Empty Set** is unique.
theorem the_empty_set_is_unique (A B : Set X) :
  (∀ (x : Particular X), ¬(x ∈ A)) → (∀ (x : Particular X), ¬(x ∈ B)) → A = B := by
    intro hA hB
    funext x
    unfold mem at hA hB
    simp [hA x, hB x]


-- # Set operations.
-- The complementary of the *Set* of A is a *Set* defined by the *Predicate* ¬P_A(_).
def compl (A : Set X) : Set X := fun (x : Particular X) => ¬(A x)
-- The intersection of the *Sets* A and B is a *Set* defined by the predicate P_A(x) ∧ P_B(x).
def inter (A B : Set X) : Set X := fun (x : Particular X) => A x ∧ B x
-- The union of the *Sets* A and B is a *Set* defined by the predicate P_A(x) ∨ P_B(x).
def union (A B : Set X) : Set X := fun (x : Particular X) => A x ∨ B x
-- The *Set* A is a subset of the *Set* B if and only if P_A(x) → P_B(x).
def subset (A B : Set X) : Prop := ∀ (x : Particular X), A x → B x

-- ## Notation
prefix:max "¬ₛ" => compl
infixl:70 " ∩ " => inter
infixl:65 " ∪ " => union
infix:50 " ⊆ " => subset

-- ## Theorems, showing that the *Set* operations are well-defined.
theorem complement_operation_is_well_defined (A : Set X) (x : Particular X) :
  x ∈ (¬ₛA) ↔ ¬(x ∈ A) := by
    unfold mem compl
    rfl

theorem intersection_is_well_defined (A B : Set X) (x : Particular X) :
  x ∈ (A ∩ B) ↔ (x ∈ A ∧ x ∈ B) := by
    unfold mem inter
    rfl

theorem union_is_well_defined (A B : Set X) (x : Particular X) :
  x ∈ (A ∪ B) ↔ (x ∈ A ∨ x ∈ B) := by
    unfold mem union
    rfl

theorem subset_relation_is_well_defined (A B : Set X) :
  (A ⊆ B) ↔ (∀ (x : Particular X), x ∈ A → x ∈ B) := by
    unfold subset mem
    rfl

-- ## Theorems showing the *Universe* and the *Empty Set* are complements.
theorem the_empty_set_is_the_complement_of_the_universe_set :
  ¬ₛemptySet = (universeSet : Set X) := by
    funext x
    unfold compl emptySet universeSet
    simp

theorem the_universe_set_is_the_complement_of_the_empty_set :
  ¬ₛuniverseSet = (emptySet : Set X) := by
    funext x
    unfold compl universeSet emptySet
    simp

end Universe
